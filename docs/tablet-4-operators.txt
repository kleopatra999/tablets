% Perl 6 Tablet 4 - Operators

> Perl folklore: Perl is an operator based language.

Perl 6 knows a huge amount of operators, because they support 2 of the
main design goals: they offer **dense** and **intuitive readable** code.
2 + 3 is certainly shorter and easier to understand then add(2,3),
since [pictograms](tablet-1-language-design.html.html#visual-metaphor)
can be picked up faster than words. (Fortran made its whole career on that).
But because they are so many, they had to be sorted by a rule named
[huffman coding](tablet-1-language-design.html.html#huffman-coding).

To understand an operator you have to know its
[**arity**](appendix-g-glossary.html#arity)
(how many [*parameters*](appendix-g-glossary.html#parameter) it takes
- usually one (!) or two (+) ).

The [**precedence**](appendix-g-glossary.html#precedence) tells
which operator to prefer in case of conflict, when no braces are used 
(round braces are only for grouping and managing precedence).
With the help of a special [table](appendix-b-grouped#table-of-precedence)
it allows 2 + 3 * 5 to return 17, not 25, which would upset your math teacher.

If two same operations are in conflict, the ambiguity gets resolved
by the operator's [**associativity**](appendix-g-glossary#associativity).
Power has right has according the same [table](appendix-b-grouped#table-of-precedence)
right precedence, so 2 ** 2 ** 3 gets resolved to 2 ** (2 ** 3) = 256,
which makes yout math teach even happier.


Assignment ops
==============

=

self assigning ops


Binding
-------

:=
::=



Comparison
==========


Smartmatch
----------

This is the most mighty (much more mighty than its backported Perl 5
twin) of all Perl 6 operators. It can be called the
"compare-this-with-that-operator". If the left side of that infix operator
matches somehow the content of the right side, it returns Bool::True,
otherwise Bool::False. The negated form !~~ naturally works the other
way around. The exact comparison operation depends on the [data
types](tablet-3-variables.html#data-types) of the values on both sides.
Just look into that [large table](appendix-b-grouped.html#smartmatch)
to check your specific case.

Smartmatching was originally invented to make [matching with
regex](tablet-9-regexes.html#matching) semantically sane.

    ~~ !~~



Equality
--------

    eqv eq == ===
    != !==



Traversing Sequence
-------------------

    ++ -- succ pred

[sequence generation](#sequence-operator)



Generic Comparison
------------------

    before after cmp



Numerical Comparison
--------------------

    < == > <=> <= >=



String Comparison
-----------------

    lt eq gt leg le ge



Joined Comparison
-----------------

    3 < $a == $a < 7

is not the same as

    3 < $a < 7

because latter is evaled at once and the first in 2 steps (left to
right).



Junctions
---------

    | & ^ !
    any all one none



Ranges
------

    .. ^



Logical Selection
-----------------

    && - and
    || - or
    // - orelse
    ^^ - xor

see also [numerical selection](#numerical-selection)



Ternary
-------

    ?? !!



Flipflop
--------

    ff fff



File Test
---------

Are now ordinary methods of the IO type.

[table of all](appendix-b-grouped.html#test-methods)



yadda
-----

    ...
    ???
    !!!



Context Forcing Scalar Ops
==========================


Bool Context
------------

    ? !
    ?& ?| ?^



Numeric Context
---------------

    + - * ** / % %%
    +& +| +^ +< +>
    mod exp sqrt sin cos tan log log10



### Numerical Selection ###

    min max minmax



String Context
--------------

    ~ x
    ~& ~| ~^ ~< ~>



List Ops
========


List Generation
---------------

The simplest way to create a list is by repeating some values:

    'munch' xx 3 # results in 'munch', 'munch', 'munch'
    ('hallo', 'echo') xx 2 --> 'hallo', 'echo', 'hallo', 'echo'

### Range Operator ###

In list context the range operator produces lists:

    @ 2 .. 7 --> 2,3,4,5,6,7


### Sequence Operator ###

    ...

[traversing sequence](#traversing-sequence)


Feed Ops
--------

    <== ==>
    <<== ==>>


Zip
---

    Z



Combinators
-----------

    X




Meta Ops
========

self assigning 
--------------


Meta R
------


Meta R
------

Meta S
------


Meta Z
------

    Z



Meta X
------

    X



Hyperops
--------

    « » << >>



Reduce
------

    [ ]



Triangle
--------

    [\ ]





precedence table
================

[is in Appendix B](appendix-b-grouped.html#table-of-precedence)



Intentionally Not Existing
==========================

XXX



Selfmade Operators
==================

How to make your own is subject [this chapter](tablet-10-metaprogramming.html#operators)
at the metaprogramming tablet.


***
